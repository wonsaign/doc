<font size=6 color=orange>Head First</font>设计模式
### 设计工具
> 模式不是被发明,而是被发现
> 设计是一门艺术,总有可取的地方
* 封装变化
* 多用组合,少用继承
* 针对接口编程,不针对实现编程
* 为交互对象之间的松耦合设计而努力
* 对扩展开放,对修改关闭
* 依赖倒置,要依赖抽象,而不是依赖具体的类
  
#### 策略模式
> 针对`变化`的部分,设计为接口,并在当前类中添加setter方法,随时切换接口的另一种实现类

![strategy](../Images/strategypattern.png)

#### 观察者模式
> 在对象的定义之间存在`一对多`的关系,这样一个状态改变,依赖它的其他对象收到通知,并自动更新.
* Subject(观察者),使用一个接口(java.util使用的是一个类Observerable来继承)

#### 装饰者模式(与 构造着模式啥区别呢?)
> `动态的添加`责任到对象上,是`弹性的继承`,是动态行为的扩展,各个装饰者都有一个共同的抽象类或接口
* 要点
  * 组件和装饰者是同一个父类继承关系
  * 装饰者的继承,`只是继承了类型,而不是继承了行为`
  * 装饰者按照顺序来装饰,装饰的过程不稳定(一旦装饰顺序错误,可能会失败)
  * 装饰者模式,类似组装
  * java IO 就是典型的装饰者模式()->new FilterInputStream(new BufferedInputStream(new LineNumberInputStream()))

![strategy](../Images/decorationpattern.png)

#### 简单工厂/工厂模式/抽象工厂模式
> 工厂模式是用来封装对象的创建的

* 简单工厂,不是一种设计模式,而是一种编程习惯,在创建产品的地方,引入工厂引用,使用工厂来实例化对象 
* 工厂模式,通过定义一个抽象工厂类,工厂类中生产产品的方法定义为抽象方法,并由子类`继承实现`,实例化不同的工厂(只生产一类产品:CPU),强调的是`生产具体产品的方式`
* 抽象工厂,通过组合的方式,创建相关或依赖对象的家族,因为不关心具体产品是什么,所以从具体的产品中解耦,它强调了不同组件(产品)之间的依赖关系(不同的CPU,显卡,内存通过不同的组合生产出的商务,游戏,学生等概念产品等等),以变在不同的上下文中实现各式各样的工厂(通过不同的组合,组合出商务本厂,游戏本厂,和学生本厂)

* 简单工厂,工厂模式和抽象工厂的不同
  * 简单工厂,是一种编程习惯,是一种重构方法
  * 工厂模式潜伏在抽象工厂中,抽象工厂的方法常以工厂模式的方法实现
  * 工厂模式,主要是`继承`,<font color=LightSeaGreen>强调具体产品生产的方式</font>;
  * 抽象工厂,主要是`组合`,强调不同的对象(抽象产品)之间的组合所产生的不同的<b>概念产品</b>,侧重点不同
  * 一般来讲,抽象工厂使用工厂模式的方法实现具体的工厂;工厂模式使用简单工厂的方法作为生产产品的具体过程

#### 命令模式
> 发出请求和执行请求解耦,被解耦对象之间是通过Command接口沟通的,如何解耦的?--通过`封装一个命令与(执行者)一组动作的关系`来参数化实现,并通过设置,将该命令设置在请求者(Invoker)众多请求(请求容器)的某一位置.

* 命令模式中有`三个角色`,
  * 真正的命令`执行者`(在命令接口的实现类中,Command接口的实现execute,undo方法内真正的执行动作的角色)
  * `命令`接口(包含execute等方法),每个命令的实现类中的execute等方法,都代表了`一组动作`
  * `Invoker`调用命令者,Invoker是一个存储着多个命令的容器,并通过setCommand方法,将命令设置在其中
* Command接口除了有execute()方法以外
  * 还要有undo()方法,来执行回退
    * 通过使用`状态`来记录,并退回
  * 宏命令,在Command接口中,定义一组命令集合,并在execute方法的视线中,逐一调用命令集合中每个命令的execute方法,实现批量命令
  * 队列请求,将实现了Command接口的运算块(实例),放入队列中,此时队列是Invoker,与运算块(命令的实现类)完全解耦,工作队列只需要知道取出命令对象,而不在乎哪个线程来执行运算块(命令的实现类),可有效的把运算限制在固定数目的线程中进行.
  * 日志请求,在命令模式中添加store/load方法,利用对象的序列化实现这些方法,将`命令`缓存在磁盘中.如:当update请求达到时,将其封装为命令接口,并调用UpdateCommandImpl实现类中的store/load方法通过序列化,将当前命令存储在磁盘中;对于高级应用而言,这些技巧可以被扩展到`事务`处理中.


#### 单例模式
