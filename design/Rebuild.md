<font size=6 color=orange>重</font>构的意义，不必再说，写的代码是给人看的，为了给自己留点脸面。
<font size=6 color=orange>重</font>构的原则：在不改变其功能的情况下进行重构。
#### 代码的坏味道
* `Duplicated Code`，重复代码。
* `Long Method`，过长的方法，寻找通过注解注释的代码块/条件表达式/循环，提炼出函数。
* `Large Class`，过大的类。
* `Long Parameter List`，参数列表太长。
* `Divergent Change`，发散式变化，一个修改引起多处变化。
* `Shotgun Surgery`，分散式修改，当添加/修改一个功能，要修改三个以上的函数。
* `Feature Envy`，依恋情结，为了计算某个值，从另外一个类取了一半的函数帮助计算。
* `Data Clumps`，数据泥团，类中相同的字段/多个函数参数都一样
* `Primitive Obsession`，基本类型偏执，很多时候，可以使用对象来代替数组。
* `Switch Statements`，使用多态来解决。
* `Parallel Inheritance Hierarchies`，平行继承，某个类增加一个子类，必须为另外一个类相应的也添加一个子类。
* `Lazy Class`，冗余类，如果一个类价值不符合本身，就应该去掉。
* `Speculative Gennerality`，夸大的作用性，某个抽象类如果没有作用，就去掉。
* `Temporary Field`，令人迷惑的暂时字段，某个类的实例变量仅为某中特殊形况而定。
* `Message Chains`，过度耦合的消息链，使用封装解决，类内应该对自己保持一致。
* `Middle Man`，中间人，封装解决。
* `Inappropriate Intimacy`，狎昵关系，两个类花费太多的时候去获取彼此的private成分。
* `Alternative Classes With Different Interfaces`，异曲同工类，两个函数做同一件事，却有不同的名字。
* `Incomplete Library Class`，不完美类类库，这个由jdk开发团队来解决
* `Data Class`，纯数据类，这个就是要加private，进行封装。
* `Refused Bequest`，被拒绝的馈赠，子类应该继承父类的全部函数和数据，这个味道很淡，依情况改动。
* `Comments`，过多的注释，当然不是指的是注释不好，不过大部分人用注解来当除臭剂，在一端又臭又长的代码上会有一段注释，这种情况非常多。

#### 方法重构:
|Method|When|How|Point|
|---|:---|:---|:---|
|`EM`[^1]|<font color=Crimson>过长的函数,或者需要一段注解才能理解时</font>|<font color=LightSeaGreen>代码独立放在一个函数中,以函数`做什么`命名</font>|`粒度较大,最基本,最终,最重要,下面所有的方法,最终目的都是使用该方法,增加粒度`|
|`IM`[^2]|当函数过于简单清晰易懂或手上有一群组织不合理的函数,可以将它们内联到一起在拆解为合理的函数|检查是否具有`多态性`,在函数调用点插入函数本体,然后移除函数|一般总为`EM`的中间手段|
|`IT`[^3]|只被一个简单的表达式赋值`一次`,唯一单独使用的情况是`作为函数的返回值`|赋值该变量为`final`,找到只被使用一次的地方用表达式替换掉|是`RTWQ`一种特例|
|`RTWQ`[^4]|以临时变量保存某个表达式的运算结果,临时变量是暂时的,如果替换为函数,可增加复用|找出只被赋值一次的临时变量[^5]并声明为final,提炼为private方法,此重构方法针对临时变量|粒度小,并且`局部变量数量少`,并且一般在`EM`方法之前|
|`IEV`[^6]|复杂表达式,较长算法或条件逻辑中的条件|将复杂表达式(或其中一部分)用一个final临时变量声明|超级麻烦,并且`EM`解决不了|
|`STV`[^7]|某个不是循环遍历或结果收集变量[^8]的临时变量被赋值超过一次,这以为它承担一个以上的责任,每个变量只承担一个责任|在该变量第二次赋值的时候,引入新的临时变量|
|`RATP`[^9]|代码对一个变量参数[^10]进行再次赋值|建立一个临时变量,将取替该变量|
|`RMWMO`[^11]|大型函数,对局部变量无法使用`EM`|将该函数放进一个单独的对象(可以是内部类),建立一个final字段保存原先大型函数所在的对象,并将局部变量变为对象的实例变量,如此可在对象中,将大型函数分解为多个小型函数.|与`IEV`相同的是都不能使用`EM`,不同的是<font color=SaddleBrown>`IEV`作用于算法,逻辑;此方法作用于局部变量关系错综复杂</font>.|
|`SA`[^12]|你想替换算法的时候|将函数本体替换为另外一个算法|这个真没啥好说的|
#### 对象重构:
|Method|When|How|Point|
|---|:---|:---|:---|
|`MM`|另外一个调用函数的次数比当前类要多|将目标函数搬移,并决定是否删除源函数,或者把它当作一个委托函数保留下来|
|`MV`|某个字段在另外一个类中使用更多|移走|
|`EC`|某个类做了应该由两个类做的事|建立一个新类,建立旧类访问新类的链接关系,用`MV`,和`MM`搬移|是否公开新类,决定成为`引用对象或不可变的值对象`|
|`IC`|某个类没有做太多事情,没有意义的|将这个类所有的特性搬移过去|
|`HD`|客户通过一个委托来调用另外一个对象,减少客户端和服务端的直接引用|在服务端建立一个简单的委托函数,调整客户端的调用,调用委托函数
|`RM`|委托函数过多,要适当的删除|与上面的`HD`正好相反|`HD`与之是相反的|
|`IFM`|<font color=Crimson>想要修改源码</font>:为某个服务类增加`一个`函数,但是<font color=LightSeaGreen>无法修改</font>这个类|在客户类中建立一个函数,用来提供功能|
|`ILE`|<font color=Crimson>想要修改源码</font>:为某个服务类增加`一些`额外的函数,但是<font color=LightSeaGreen>无法修改</font>类,通常使用`子类化`或者`包装`统称为本地扩展|建立一个扩展类(子类/包装),在扩展类中加入转型构造函数[13]|`IFM`是修改一个,`ILE`是修改一堆|

#### 数据重构:
|Method|When|How|Point|
|---|:---|:---|:---|
|`SEF`|封装|字段封装|
|`RDVWO`|当最开始用"字符串"来表示电话号码时,后续发现,电话号多了很多属性--格式化,抽取号码,靓号租费等等|创建一个新类,声明一个final字段,并在构造函数中赋值,在调用该字段的原类中,赋值使用构造函数,获取用get方法|
|`CVTR`|值对象和引用对象[^14],一个类衍生出许多相等的实例|使用工厂代替构造函数,同事构造函数私有化|
|`CRTV`|一个引用对象,很小不可变,不易管理|如果无妨将对象改为不可变的,放弃;若可以,建立equals和hashCode方法保证相等|不可变对象在分布式和并发中非常有用|
|`RAWO`|有一个数组,各中元素代表不同的东西|建立对应的字段|
|`DOD`|GUI相关|观察者模式|
|`CUATB`|两个类都要使用对方的特性,但是目前是单向关联,需要增加'反向指针'||
|`CBATU`|双向关联改为单向关联||
|`RMNWSC`|有一个具有特别含义的字面数值|用常量代替魔法数|
|`EF`|封装|private -> get and set|
|`EC`|封装集合||
|`RRWDC`||
|`RTCTC`|类中有一个数值码类型,它`不影响`类的行为,如果将值变为类,编译器会启动类型检测|TODO|
|`RTCWS`|有不可变类型码,`会影响`类的行为|使用多态代替|
|`RTCWS`|上面的多态不灵了,要用状态模式和策略模式|TODO|
|`RSWF`|常量函数[^15]|针对每个常量,在超类中生命一个final字段,使用protected构造函数初始化新增字段,新建或修改子类,调用超类的构造函数|

#### 条件重构:
|Method|When|How|Point|
|---|:---|:---|:---|
|`DC`|if else if else ...|if else|
|`CCE`|一系列条件测试,得到相同的结果|合并|
|`CDCF`|每个条件分支上有相同的代码|相同的代码移出条件表达外|
|`RCF`|不要使用flag控制分支|使用break/continue;return语句|
|`RNCWGC`|函数中的逻辑让人看不清楚,全是if...else...,那么使用卫语句[^16]|基本功|
|`RCWP`|用多态来代替switch case|子类函数重写,父类抽象函数|
|`INO`|再三检查对象是否为null,使用null对象代替|为源类创建一个子类,源类和子类都创建isNull函数,前者返回false,后者是true|
|`IA`|只有条件为真,才能运行,代表了绝对|Assert|必须是`绝对`的才可以|

#### 简化函数重构:
|Method|When|How|Point|
|---|:---|:---|:---|
|`RM`|函数名称不能准确表达其用途|`声明一个新函数`,将老函数放入其中|
|`AP`|修改函数时,要增加新的字段|声明一个新函数,添加上新字段|
|`RP`|某个参数字段根本没有使用,对于没有使用的函数必须去除|声明一个新函数,去掉无用的字段|
|`SQFM`|某个函数既有返回状态值,又修改状态|建立两个不同的函数,一个select,一个update|
|`PM`|若干函数做了相同的内容,只有少数几行不同|新建一个带有参数的函数,抽取重复代码部分|
|`RPWEM`|有个函数,完全取决于参数值不同而不同|建立独立函数|与`PM`恰恰相反|
|`PWO`|一个函数的参数两个以上的参数,来自于同一个对象|用对象代替参数|
|`PPWM`|两个表达是A和B,其内容完全相同,但是却各自作为函数M的参数|去掉重复的|
|`IPO`|特定的一组参数总是被一起传递,可能有多个函数都使用了,使用参数对象来代替|新建一个类,声明所有的字段都为final(不可变对象),只能获取|
|`RSM`|某个字段不可被修改|声明为final 只有构造函数才能赋值 只有get方法|
|`HM`|有个函数从来没有被用过|public -> private|
|`RCWFM`|创建对象的时候,不只是简单的new,比如根据类型码(黑人/白人/黄人)创建不同的对象|使用工厂模式代替|
|`ED`|向下转型|已经被泛型搞定了|
|`RECWE`|某个函数返回特定的代码,代表了某种错误|用异常代替|
|`REWT`|异常只被应用于异常的罕见的行为,也就是意料之外的行为,而不是作为if条件的替代品,数组越界,应该有程序来判断,而不是抓异常|使用if表达式,来判断明明知道的错误,而不是用exception|

#### 概括关系重构:
|Method|When|How|Point|
|---|:---|:---|:---|
|`PUF`|多个子类具有相同的字段|移动到父类|
|`PUM`|多个子类具有相同的函数的结果|移动到父类|
|`PUCB`|多个子类的构造函数,基本上一样|移动到父类|
|`PDM`|超类中,某个函数只与部分子类相关|移动到子类中,复制超类的函数,如果不是public,设置为protected|
|`PDF`|超类中,某个字段只与部分子类相关|移动到子类中|
|`ES`|父类中某些特性只被部分使用|TODO|
|`ES`|两个类具有相似的特性|TODO|
|`EI`|TODO|TODO|
|`FTM`|TODO|
|`RIWD`|TODO|
|`RDWI`|TODO||与`RIWD`恰恰相反


[^1]:Extract Method,函数替代
[^2]:Inline Method,内联方法
[^3]:Inline Temp,内联变量
[^4]:Replace Temp with Query,以查询方法代替临时变量
[^5]:如果临时变量不被赋值一次,就不改使用此方法重构.
[^6]:Introduce Explaining Variable,引入中间解释变量
[^7]:Split Temporary Variable,分割临时变量
[^8]:包含了:i++;str+"abc",IO,Collection
[^9]:Remove Assignments to Parameters,移除参数赋值
[^10]:java只有值传递一种,所谓引用传递只不过传递的是地址的数值.
[^11]:Replace Method with Method Object,用对象方法代发
[^12]:Substitute Algorithm,替换算法

[^13]:转型构造函数是指"接受原对象作为参数"的构造函数,子类化用超类;包装得到实例,作为委托的原对象.
[^14]:值对象就是不可变类(如日期),final修饰的类或者final修饰的属性,不可变类值得是内容不可变,而不是应用不可变;引用对象(账号)就是创建对象改为工厂模式,同时私有化构造函数;
[^15]:各个子类的唯一差别,只是在'返回常量数据上'的函数身上
[^16]:卫语句,如果某个条件满足,立刻从函数中跳出返回