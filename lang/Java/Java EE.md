## Java EE 核心模式
> javaEE中大量的实现核心模式
> 模式成立的条件是:上下文;问题;解决方案三者缺一不可

### Http 服务端
* 分布式服务器保存会话Session的两种方式
  * 负载均衡,多个服务器会话进行复制
  * `服务器亲和性`,一台服务器处理一个用户的请求

* 表单重复提交
  * 使用"同步器令牌",提交表单的时候校验令牌,通过后就更换令牌

* 表现层`不佳`实践
  * 多个视图中包含控制代码
    * 解决方式:引入控制器
  * 表现层数据暴漏给业务层
    * 解决方式:1,把业务层专用数据抽出来;2,将相关的数据状态复制出来,让两个层次共享抽象数据
  * 表单重复提交
    * 解决方式:同步器令牌或者表单校验
  * "胖"控制器
    * 解决方式:使用命令模式包装?
  * 视图中写入过多的script
    * 使用jstl标签
* 业务层和集成层的不佳实践(Spring提供了EJB管理容器)
  * 把对象模型直接映射为entity bean,EJB的容量越多,容器的负担就越重
    * 解决方式:找到父子关系,细粒化Bean;使用复合实体模型;重构使用门面模式(Dao,Service,Controller)
  * 通过getter/setter暴漏所有的EJB属性
    * 使用值对象?
  * 在客户端中包含服务寻址代码,在EJB中,容易利用`JDNI`提供寻址服务.

## J2EE 模式概览
* 表现层模式
  * 拦截过滤器 
    >想要避开多层if...then...else...的代码结构.
    * 拦截之前要有有一个前置处理和有一个后置处理,那么拦截前和拦截后可以使用`模板模式`,中间的拦截式可插拔的部分可以使用`过滤器模式`,也可以增加`装饰者模式`,对于某个过滤器的增强处理.
    * 过滤器和装饰者非常从相像,很自然就可以融合在一起.此外特别适合预处理/后处理的强大策略.
  * 前段控制器
    >想要避免重复的控制代码,并且集中到同一个位置的时候.
    * 表现层处理请求增加一个集中访问点
    * 前段控制器的优点:
      * 能统一处理请求
      * 对请求进行分发到不同的视图
      * 