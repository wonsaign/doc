### JVM笔记

#### 类加载的过程.
* 类加载的过程,就是将`.class`文件加载到虚拟机内存中到过程.
![classloader](../../../Images/programming/java/jvm/classloder.png)

#### JVM内存模型
> JVM 虚拟机内存模型


![JVM虚拟机](../../../Images/programming/java/jvm/JVM虚拟机.png)

##### 栈内字节码的执行
> 栈内的栈帧的执行,粗略展示.

![JVM虚拟机](../../../Images/programming/java/jvm/栈的执行.gif)
* 有关上图中的动态链接.
[动态链接](jvm栈中的动态链接.md)


##### 堆内存空间示意图
> 下面是堆的内存空间.
> 由年轻代和老年代组成,默认大小比例1:2
> 年轻代中由eden,survivor0,survivor1组成,默认大小比例8:1:1
> 老年代对象和年轻代对象直接会存在引用. 比如School对象已经在老年代,但是里面有一个对象代引用Student改成了,那么新的Student对象就会在年轻代和老年代的School互相关联着.

Young GC的过程.
![classloader](../../../Images/programming/java/jvm/堆内存示意图.gif)



#### JVM运行模式
* `解释模式`,程序执行到哪一行,将哪一行解释执行为0101机器码,不会缓存
  **启动快,运行不如编译模式,占用空间小**
* `编译模式`,直接将所有到代码全部编译成0101机器码,放入缓存,Just In Time Complier,即使编译技术,即JIT.编译过程中,会对代码进行优化,比如对象逃逸分析.
  **启动慢,运行快,占用空间大**
* `混合模式`,普通程序依然使用解释模式,但是热点代码改为使用编译模式(也会执行JIT).既减少了空间,又增加了速度,默认使用这个模式.
* 对象逃逸分析.
  ```
    在jvm中使用编译模式模式下编译生成机器码的时候:
    当一个方法中的对象,不会在这个方法外使用(简单点说,就是不会被返回)
    那么这个对象的空间就会由栈来生成.减少堆空间的浪费,减少gc
  ```

####JVM垃圾回收时机
* 堆中垃圾回收情况:
  >假设年轻代总大小100M,老年代200M
  >young -> `eden 80M` `survivor0 10M` `survivor1 10M`
  1. young gc后存活的对象survivor区存放不下,即剩余对象大于10M
  2. 大对象直接进入老年代,为了比避免大对象在suivivor区复制的低效率.可以使用-XX:PretenureSizeThreshold指定大小,超过这个大小直接进入老年代.
  3. 长期存活的对象会进入老年代:每在survivor区存活一次,年龄加一的“顽固”对象,当达到年龄限制就会进入老年代.可以使用`-XX:MaxTenuringThreshold`来指定年龄,由于是4个bit存贮,所以`默认最大16岁`.
  4. 动态年龄判断机制.
        ```
        当前对象的survivor区其中一块区域(s0或s1),当一批对象中总大小超过50%当时候(可以使用-XX:TargetSurvivorRatio设置,默认50%),超过的部分会进入老年代.
        比如:
        survivor区中
        1岁对象总大小2M;
        2岁对象总大小3M;
        3对象总大小1M;
        4岁对象总大小0.5M;
        5岁对象总大小1M;
        此时总的存活对象大小2+3+1+0.5+1=6.5 > 10M * 50%
        那么超过50%部分年龄较大的对象放入老年代
        比如5岁总大小1M的对象,4岁总大小0.5M的对象,3岁总大小1M的对象提前进入老年代.
        ```
  5. 老年代的空间担保机制.(jdk1.8以后已经默认配置了.)
  ![classloader](../../../Images/programming/java/jvm/老年代担保机制.png)

####JVM垃圾回收算法.
* 标记-清除算法(标记后,清理对象)
  ```
  缺点:
  先标记再清理效率低;
  空间碎片;
  ```
* 复制算法(准备将两块儿大小相同的内存,每次只清理一块儿,并复制到另外一块儿.)
  ```
  缺点:
  需要预留出一半的空间,浪费空间;
  优点:
  通过gc-roots判断存活后,直接清除,不标记,速度快.
  无空间碎片.
  ```
* 标记-整理算法(标记后,整理在一起)
  ```
  优点: 
  无空间碎片.
  ```
* 分代算法(一种思想,jvm已经使用了.)
* 
#### 垃圾收集器
> 垃圾收集的时候,为保证能正确清理,会暂停所有的线程.然后清理,这种现象叫“Stop The World”,简称STW
* Serial收集器,单线程收集器,GC时候“Stop The World”
  ```
  年轻代使用复制算法
  老年代使用标记-整理算法
  ```
* ParNew收集器,多线程收集器,GC时候“Stop The World”
  ```
  年轻代使用复制算法
  老年代使用标记-整理算法
  ```
* Parallel Scavenge
* **CMS收集器**,老年代收集器.
Concurrent Mark Sweep,同步标记清除,以获取最短的“Stop The World”的时间.
  ```
    初始标记:“Stop The World”    GC线程标记gc-roots能直接引用的对象,速度快.
    并发标记:No “Stop The World”  应用程序正常运行和GC线程继续标记并发.(此处占用gc时间的80%时间)
    重新标记:“Stop The World”    该阶段的任务是完成标记整个老年代的所有的存活对象(此处会产生浮动垃圾:GC线程标记上个阶段由于应用程序和GC线程并发时应用程序新产生的垃圾对象)
    并发清理:No “Stop The World”  应用程序正常运行和GC线程清理.
    -------
    容易产生的问题:
    CPU资源敏感;
    内存碎片
    无法清除'浮动垃圾'
  ```
  * CMS垃圾收集器参数调整:
    * `-XX:+UseConcMarkSweepGC` 启用CMS
    * `-XX:+UseCMSCompactAtFullCollection` Full GC后做压缩整理(减少碎片)
    * `-XX:CMSFullGCsBeforeCompaction=n`  CMS进行n次full gc后进行一次压缩。如果n=0,每次full gc后都会进行碎片压缩.
    * `-XX:CMSInitiatingOccupancyFraction=n` 当老年代内存使用达到n%,开始回收。
    * `-XX:+UseCMSInitiatingOccupancyOnly` 如果不指定, 仅在第一次FUll GC用设定的回收阈值.
    * `-XX:+CMSScavengeBeforeRemark` 在使用CMS收集器执行FUll GC之前,先执行一下Minor GC,减少年轻代中的垃圾对象.
* **G1收集器**



* Full GC也会回收方法区中的垃圾回收,必须全部满足下面3个条件才会被回收.
  1. 该类的所有实例在堆中都被回收
  2. 加载该类的ClassLoader被回收
  3. 该类对应的Class对象没有在任何地方被引用,即无法在任何地方通过反射获取该类的方法.


#### 调优专题
* 调优的原则是(每秒产生多少垃圾对象)
  * 尽量减少full gc.希望在年轻代中通过minor gc就清除掉.
  * 希望大对象尽量少在年轻代中增加岁数后才到老年代.所以可以`设置大对象参数`的阀值
  * 保证老年代分配担保机制成功.
* 亿级流量电商丁订单JVM参数设置.
  * **分析的思路很重要**.
    1. 假设平均用户平均点击二,三十次.
    2. 日活跃用户= 1亿/20 = 500万
    3. 付费转化率10% = 50万单
    4. 正常集中在3-4个小时的订单-> 每秒几十单
    5. 大促可能每秒1000单
    6. 将系统进行水平分布式架构(分成3个机器)
    7. 每个机器300单/秒
    8. 假设每个对象1kb,每秒30kb(可以使用JOL查看对象的大小.)
    9. 涉及到其他优惠卷等等 估算20倍. 6000kb = 6M
    10. 如何还有订单的增删改查等等,操作数*10 = 60M 
    11. 最终每个服务器 ->每秒生成60M垃圾对象.
    12. 如果以每个服务器4g内存空间,那么年轻代中的内存比例就是1.2g:0.15g:0.15g,根据动态对象年龄机制.第一秒0岁的60M垃圾,存在S区,第二秒0岁的60M垃圾变成了1岁了,新的0岁和1岁加起来超过了50%,则1岁的60M垃圾就会进入老年代. 所以调整动态对象年龄机制的比例或者调大S区的内存大小.
  * 下面是分析流程图.
![classloader](../../../Images/programming/java/jvm/亿级流量电商垃圾对象分析.png)