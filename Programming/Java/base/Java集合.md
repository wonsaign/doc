#### Java集合
##### Collection
> 此处缺一个图,补充一下


##### Map
> Map实现了一中K—V对应的关系,在java中有非常大的应用.
* HashMap属性认知
  * 下图是HashMap中的重要属性
  ![HashMap结构](../../../Images/programming/java/base/HashMap结构.png)
* HashMap非常重点
  * 下面是**字符串** “1-16” 的hash散列分布
    ```
    key.hash   key     n - 1   table[key.hash & n - 1]
    49          1       15         1
    50          2       15         2
    51          3       15         3
    52          4       15         4
    53          5       15         5
    54          6       15         6
    55          7       15         7
    56          8       15         8
    57          9       15         9
    1567        10      15        15
    1568        11      15         0
    1569        12      15         1
    1570        13      15         2

    容器为默认大小16,阀值为16*0.75=12.(实际上并不是这么算的)
    为何没有14,15,16呢? 因为超过阀值会扩容,注意,这里是放入13个元素后开始扩容的,不是12个
    if (++size > threshold)
      resize();
    ```
  * 由上面可以看出,hash碰撞的情况非常的小,只有table[1],table[2]有两个元素,然后会被扩容
  * table数组说是数组,其实可以看作是一个**散列接盘器**,HashMap之所以接近O(n),是因为扩容要由于链表
  * 其实Map容器的是不满载的,比如声明16个空间,最多放入12(阈值)个(当放入13个后开始扩容),所以当超过阈值的时候,**扩容是优先于链表的追加的**.当链表长度超过8,则尝试变为tree,如果当前hashmap当table.size小于64则首先进行扩容,已经超过64个了,则会进行转化树.
    * 所以最良好的情况是12个元素,填满12个table的slot
    * 最差的情况是所有的key经过运算,最终只占一个table的slot,然后12个长度的链表(超过8个会尝试变为tree)
*  **转化树的条件**
    * 当前链表长度超过8
    * 当前hashmap的容量大于等于64
    ``` 
    map容量16
    key是String  1  12  23  34  45  56  67  78  89  100  111  122 
    都会落在table[1]的结点位置,可以测试出链表转tree(但是实际上是转换不成的,因为我的容量不够64)
    此数据帮助测试
    ```
* 从树转换回链表的时候,就是当树的节点数小于等于6的时候.
* 扩容的时候,是线程不安全的(无论是1.7还是1.8,1.7会形成环路,1.8不会.)
  * 为什么这么说? 
  * 如果两个线程在resize方法外调用,线程T1正在resize,正在搬运,T2此时开始扩容,那么table[key.hash & n - 1]就会不准确,因为n变了,之前是T1的时候n是32,T2的时候n是64,两次与运算的结果不一样,所以是不安全的.
* ConcunrrentHashMap

* HashMap源码解读.
  1. put(k,v)放入值,下图来源于网络,我觉得总结的非常到位,所以借鉴过来,稍稍修正
    ![HashMap结构](../../../Images/programming/java/base/java-hashmap-put-修改版.png)
  2. resize()扩容,整个图就来自于我自己了.图中阐释了jdk1.8以后的map扩容机制,
    ![HashMap结构](../../../Images/programming/java/base/java-hashmap-resize扩容步骤图.png)
  3. 为什么说jdk1.8的map不会产生死锁呢?
      ```
      由于1.7的map扩容的时候,是讲原来的链表顺序反向存入新的table中,所以多个线程扩容的时候,容易产生**死链**.

      而1.8以后的扩容,可以看到,非常巧妙的进行了高低位运算,好处是
        * 可以更有效的将table中的slot利用上
        * 当多个线程一起进入当前方法时,运算结果一致性.
      ```


##### List
###### ArrayList
* 数组扩容,每次1.5倍,默认容量是10

###### LinkedList
* 是个链表
* 应用
  * 使用过LinkeList做过区间重复性检测(不可有交叉重复区间) 思路如下:
    1. 将所有区间的开始从小到大排序
    2. 循环添加的时候,判断条件-> 空区间或者链表的getLast小于当前的开始,链表addLast
    3. 如果链表的getLast大于当前的开始,则说明有交集.
