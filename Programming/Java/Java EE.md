## Java EE 核心模式
> javaEE中大量的实现核心模式
> 模式成立的条件是:上下文;问题;解决方案三者缺一不可

### Http 服务端
* 分布式服务器保存会话Session的两种方式
  * 负载均衡,多个服务器会话进行复制
  * `服务器亲和性`,一台服务器处理一个用户的请求

* 表单重复提交
  * 使用"同步器令牌",提交表单的时候校验令牌,通过后就更换令牌

* 表现层`不佳`实践
  * 多个视图中包含控制代码
    * 解决方式:引入控制器
  * 表现层数据暴漏给业务层
    * 解决方式:1,把业务层专用数据抽出来;2,将相关的数据状态复制出来,让两个层次共享抽象数据
  * 表单重复提交
    * 解决方式:同步器令牌或者表单校验
  * "胖"控制器
    * 解决方式:使用命令模式包装?
  * 视图中写入过多的script
    * 使用jstl标签
* 业务层和集成层的不佳实践(Spring提供了EJB管理容器)
  * 把对象模型直接映射为entity bean,EJB的容量越多,容器的负担就越重
    * 解决方式:找到父子关系,细粒化Bean;使用复合实体模型;重构使用门面模式(Dao,Service,Controller)
  * 通过getter/setter暴漏所有的EJB属性
    * 使用值对象?
  * 在客户端中包含服务寻址代码,在EJB中,容易利用`JDNI`提供寻址服务.

## J2EE 模式概览
* 表现层模式
  * 拦截过滤器 
    >想要避开多层if...then...else...的代码结构.
    * 拦截之前要有有一个前置处理和有一个后置处理,那么拦截前和拦截后可以使用`模板模式`,中间的拦截式可插拔的部分可以使用`过滤器模式`,也可以增加`装饰者模式`,对于某个过滤器的增强处理.
    * 过滤器和装饰者非常从相像,很自然就可以融合在一起.此外特别适合预处理/后处理的强大策略.
  * 前段控制器
    >想要避免重复的控制代码,并且集中到同一个位置的时候.
    * 表现层处理请求增加一个集中访问点
    * 前段控制器的优点:
      * 能统一处理请求
      * 对请求进行分发到不同的视图
      * 减少代码重复
      * 明确职责分配
  * Context对象
    >个人理解，Context其实是一种思想，如果我想使用其他容器里的内容，就需要在程序中实例化容器并获得，但是实例化容器需要很多其他的协议（比如Http容器，需要Http协议相关的内容），我只是想要其的内容，不想知道协议细节，所以应势而生产生的Context容器，通过接口形式就可获取容器内的内容。（不是缓存思想）隐藏细节这点，类似门面模式.
    * 提高可维护性 
    * 减少接口变化的限制
    * 降低了性能，但是轻微的性能影响换来可维护性的增加。
  * 应用控制器（MVC）
    > 集中模块化进行操作管理和模块管理
    * 通常表现层的作用一般是
      * 解析请求，并处理请求。Make Model
      * 组装视图并分派视图。dispatch View
    * 这种请求-相应分开的机制，是命令模式最好的使用方式。
    * 最著名的应用控制器Struts。正确的请求流程式：
      * 首先Action，前端控制器（Control）
      * 其次QuestProcessor,请求处理器,正是一个`应用控制器`
        * 解析业务后，make Model
        * 使用CommandMapper，命令映射器（通过xml的配置方式），类似于Map的作用，为每一个命令配置一个视图句柄映射
  * 视图助手
    >Jsp就是成型的应用。不可能在代码中一直转义显示页面，需要一种更好的支持方式。视图助手通过POJO、定制标记等填充内容。助手在Model和View之前起到了适配器的作用。
  * 复合视图
    > footer，header等等通用视图就是复合视图的应用。
* 业务层模式（优秀的好思想）
  * 服务定位器
    >为减少多次使用JNDI进行寻址调用，增加重用性，所以使用服务定位器，一般都是使用的是单例模式，外加上缓存。
    * 模式组件：
      * ServiceLoader，封装了API寻址等复杂的方式。
      * Cache，保留以前寻址的应用。
      * InitialContext，初始化上下文，是整个寻址，创建过程的起点，每一个寻址地址，都会提供不同的Target
      * Target，寻址目标，根据寻址的上下文对象不同，返回的Target目标也不尽相同。
  * 会话门面（经常用，比如mybatis session）
  * 应用服务
    > 就是经常使用的Service层
  * 业务对象
    > 如果比较简单单一，那么一个数据访问对象即可，但是一旦系统复杂，就会造成系统混乱不堪，代码难以维护，另外也暴露了各个模型层之间的访问细节。所以要使用对象模型，把业务数据和业务逻辑分割开来。
    * 实现方式：
      * POJO
      * 复合实体模型