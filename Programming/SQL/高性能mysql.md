## 高性能mysql读书笔记

### 事实上
mysql总是将结果放入临时表，然后在读出，返给客户端。
PostgreSql擅长一些空间信息存贮。

### 数据类型
* 整数类型 tinyint，smallint，mediumint，int，bigint  可以存贮的数字范围分别2的是8，16，24，32，64次幂大小
  * 建议，如果是整数，建议使用无符号的数据类型，unsigned，范围更大
* 字符串类型
  * varchar和char
  * 前者是可变长度， 后者是定长长度
  * varchar（10）代表了可以存储10个字`符`长度的空间，不论是中文还是汉字，都只能容纳10个字符的长度。
  * 由于varchar是可变的，更能节省空间，同时varchar由于可变，所以变更字符时需要额外的工作，所以适合不太改动的字符串。或者是使用了utf-8这种复杂的字符集，每个字符使用不同的字节数来存储。
  * char，定长，使用固定空间，不会产生空间随便，所以'status'可以定义为char（1）,只存储Y或N
* BLOB和TEXT
  * BLOB是二进制的
  * TEXT是字符类型的
  * 如果字符过大，BLOB或者TEXT会使用额外的空间进行存贮
* DATETIME和TIMESTAMP
  * DATETIME，1001-9999年，精确度秒，8字节存储
  * TIMESTAMP，unix时间戳，1970-2038，4字节存储
  * 通常使用TIMESTAMP，因为空间更小。
  * 如果想存贮毫秒级别的，建议使用bigInt类型代替时间戳
* BIT数据类型可能会有问题，因为有可能存储的是字符串，00111001，有可能是二进制57，也有可能是ASCII的9，所以尽量避免使用BIT，可以使用char（1）代替
* ID列
  * 尽量使用自整整数列
    * 因为，可以使每个页的存贮达到最大的填充因子。达到一种近似填满的效果。
  * 字符串（uuid，md5）占用空间大，缺点
    * insert慢，因为uuid插入的随机性，导致页分离，磁盘随机访问
    * select会很慢，因为相邻的行之间在磁盘的位置距离很远
  * 如果非要用uuid，去掉“-”，然后将其用16进制工具转换成对应的数字。
* alter table的原理是创建一个新表，将旧表的数据倒入，如果数据量大会很慢，会花费数小时或者数天完成
  * 优化方式：alter column，只是修改.frm文件，不涉及到copy数据

### 高性能使用索引
#### 索引
* 索引类型B-Tree
  * 根据不同的存贮引擎，使用的大不相同，NDB使用的TTree，Inodb使用的B+tree
  * B+Tree的有效匹配
    * 全匹配
    * 最左匹配
    * 匹配列前缀
    * 最左范围匹配
  * B+Tree的使用限制
    * 中间列，不能使用索引
    * 不能跳列，索引ABC，不能使用AC条件
    * 使用范围的列，后面的索引条件失效，ABC，B>'10',C无效
* Hash索引
* 空间索引R-Tree，myISAM支持空间索引
#### 高性能使用
* 不在sql条件中使用表达式
* BLOB和TEXT必须使用前缀索引，mysql不允许索引这些列的全部长度。
* 唯一列使用唯一索引。
* 前缀索引的建立方式。
  *  select count（distinct  left（city_name，3））/count（*） from city ,如果接近0.031基本上就可用列。
  *  select count（*） as times， left（city_name， 3） as pref from city group by  pref limit 0,10 选择合适的次数，直到次数在40以内为好
  *  创建索引 alter table city add key （city_name（7））
  *  注意，无法使用前缀索引做order by 和group by ，以及覆盖索引
* 合适的索引顺序
  * 选择性最高的放在前面（不需要排序的情况下）
  * select sum（staff_id = 2）, sum(costum_id = 555) from payment, 查看重复率，sum越小越适合放在前面
  * select count（distinct  sum（staff_id）/count（*），（distinct  sum（costum_id）/count（*） from payment ，选择重复率最小的列
* 聚集索引的优缺点
  * 优点：
    * 数据关联，IO次数少
    * 访问速度快
    * 使用覆盖索引的适合，可以使用叶子节点的主键值
  * 缺点：
    * 插入速度，严重依赖插入顺序，如果插入的不是主键
    * 更新聚集索引列代价极高，所有的数据全部后移。
    * 可能导致页分离？ 不懂
    * 可能导致全表扫描变慢
    * 非聚集索引需要两次索引查找才可以找到数据列
    * 非聚集索引可能比想象中的更大
  * 最佳使用，整数自增，但也有些许缺点，大量并发可能产生间隙锁过多。
  * 覆盖索引，无需回表查询
    * 优点，索引条目远小于数据行大小
    * 按照条件查找的数据，如果回表，磁盘IO增加，可以减少磁盘IO
    * InnoDB，可以减少回表查询
  * 使用索引来做排序
    * 如果索引条件不能完全覆盖排序条件，就会进行回表查询进行排序
    * 使用方式，排序必须和索引创建的排序抑制
    * 最左前缀方式。
  * 冗余索引和重复索引
    * 重复索引：mysql允许重复创建同一个列的索引，但是由于查询时，执行器要进行选择，会影响性能
    * 冗余索引，（A，B）和（A）
### 查询优化
* 让mysql使用in查询，代替关联查询，按照in内的顺序，可能比随机性要更快。
* mysql客户端和服务端是半双工的，
  * 任何时刻，只能是客户端向服务端发数据，或者服务端向客户端发数据。这种方式简单，但是限制了速度，一方传输数据，另外一方只能等待，所以要使用limit进行流量限制，尽量少传数据。
* mysql优化器
  * 并不是按照查询中的指定的顺序进行，而是会优化
  * outer join 可能转变为 inner join
  * 简化表达式 `(a<b and b=c) and a = 5`->`b > 5 and b=c and a=5`
  * 优化count，max，min函数
  * 预估并转化为常量表达式
  * 覆盖索引扫描
  * 子查询优化
  * 提前终止查询
  * 等值传播
  * 列表IN和or，其他数据中等in和or可能完全相等，mysql却不是，mysql是先对in中的数据进行排序，然后二分查找是否满足。当in中有大量数据的时候比较快。
* 关联查询
  * 优化
    * **确保On条件上是索引列，并且数据量小的放在前面**
    * **order by 和group by 只涉及到一个表中的列**
* 排序优化（文件排序）
  * 当不能使用索引进行排序的时候，当数据量小则在内存中排序，当数据量大则在需要使用磁盘进行排序。
  * 关联查询排序
    * 当排序完全在一个表的时候，处理第一个表的时候就已经进行了排序
    * 其他情况都是using temporary和using filesort，即使有`limit`,limit会在排序后使用，所以所用不大。（5.6会先limit）
* 关联子查询,**尽可能使用关联查询代替**，5.6版本以后请忽略。
* count（）优化
  * 行数用count（*）
  * 列数内的数值加和直接写列名称。
* group by优化
  * 如果没有走索引列，通常使用where 条件中的列作为分组，效率会更高。
* limit 优化
  * limit 1000，20 为何要优化，因为会查询出1020条数据，丢弃前面的1000条，只要20条。
  * 20变大，变为50（治标不治本）
  * 使用覆盖索引
  * 记录上一次查找的id，where id > lastIdNum limit 20
* union
  * union，是将一次查询出的数据放入临时表，然后再重新读出数据进行union完成查询。
  * union的限制，比如 （select 语句a union select 语句b ）limit 20， 会全表扫描a和b然后在limit，改为 （select 语句a limit 20  union select 语句b limit 20 ）limit 2
  * 一定要使用union all，因为union包含了distinct去重（会给临时表使用distinct，整个临时表做唯一性检查，代价非常大。）